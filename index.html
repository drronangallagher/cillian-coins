<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Cillian's Coin GOAT Game</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
:root{
    --bg1:#eef2f7;
    --bg2:#d9e2ec;
    --card:#ffffff;
    --text:#243447;
    --muted:#6b7b8b;
    --border:#dde6f0;
    --shadow: rgba(0,0,0,0.12);
    --btn:#f7f9fc;
    --btnHover:#eef3f8;
    --accent:#e9f5ff;
    --accentBorder:#bcdfff;
}

*{ box-sizing:border-box; }

body{
    margin:0;
    font-family: Arial, sans-serif;
    color: var(--text);
    background:
        radial-gradient(1200px 600px at 15% 10%, rgba(255,255,255,0.8), rgba(255,255,255,0) 60%),
        radial-gradient(900px 500px at 85% 20%, rgba(255,255,255,0.65), rgba(255,255,255,0) 55%),
        linear-gradient(135deg, var(--bg1), var(--bg2));
    min-height:100vh;
    padding:20px;
    display:flex;
    justify-content:center;
    align-items:flex-start;
}

#app{
    width:100%;
    max-width: 1040px;
    background: var(--card);
    border-radius: 14px;
    box-shadow: 0 10px 30px var(--shadow);
    padding: 22px 18px 26px 18px;
    text-align:center;
}

h1{
    margin: 0 0 8px 0;
    color:#2c3e50;
    letter-spacing: 0.2px;
}

#subhead{
    margin: 0 0 14px 0;
    color: var(--muted);
    font-size: 14px;
}

#controls{
    margin: 10px 0 16px 0;
}

button{
    font-size: 15px;
    padding: 8px 12px;
    margin: 4px;
    cursor: pointer;
    border-radius: 8px;
    border: 1px solid #ccd6e0;
    background: var(--btn);
}

button:hover{ background: var(--btnHover); }
button:disabled{ cursor:not-allowed; opacity:0.6; }

#question{
    font-size: 22px;
    font-weight: 700;
    margin: 12px 0 6px 0;
}

#helperLine{
    margin: 0 0 10px 0;
    color: var(--muted);
    font-size: 14px;
    min-height: 18px;
}

/* Coin sizes (approx proportional to real UK coins) */
:root{
    --coin-1p: 70px;
    --coin-2p: 78px;
    --coin-5p: 72px;
    --coin-10p: 74px;
    --coin-20p: 72px;
    --coin-50p: 80px;
    --coin-100p: 78px;  /* ¬£1 */
    --coin-200p: 82px;  /* ¬£2 */
}

/* Coin tray */
#coins{
    display:flex;
    justify-content:center;
    align-items:flex-end;
    flex-wrap:wrap;
    gap: 12px;
    margin: 16px 0 10px 0;
    padding: 8px 6px;
    position: relative;
}

/* Wrap draws a ring around the coin */
.coinWrap{
    width: var(--sz, 78px);
    height: var(--sz, 78px);
    border-radius: 999px;
    border: 4px solid transparent;
    background: rgba(255,255,255,0.75);
    display:flex;
    justify-content:center;
    align-items:center;
    box-shadow: 0 6px 14px rgba(0,0,0,0.08);
    transition: border-color 240ms ease, transform 240ms ease;
}

.coinWrap.groupStart{ margin-left: 18px; }

.coinImg{
    width: calc(var(--sz, 78px) - 10px);
    height: calc(var(--sz, 78px) - 10px);
    border-radius: 999px;
    object-fit: cover;
}

#dividerSymbol{
    font-weight: 800;
    color:#51606f;
    font-size: 26px;
    margin: 0 4px;
    user-select: none;
    align-self: center;
}

#answerRow{
    display:flex;
    justify-content:center;
    align-items:center;
    gap: 10px;
    flex-wrap:wrap;
    margin-top: 10px;
}

#answerBox{
    display:inline-flex;
    align-items:center;
    font-size: 18px;
}

#prefix, #suffix{
    font-size: 22px;
    margin: 0 6px;
    min-width: 20px;
    text-align:center;
}

input{
    width: 160px;
    font-size: 18px;
    padding: 7px;
    border-radius: 8px;
    border: 1px solid #cfd8e3;
    text-align:center;
}

#feedback{
    font-size: 20px;
    margin-top: 12px;
    min-height: 26px;
}

#solutionWrap{
    margin-top: 12px;
    display:none;
}

#solutionCard{
    background: #f7f9fc;
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 14px 14px;
    max-width: 980px;
    margin: 0 auto;
    text-align:left;
}

#solutionTitle{
    font-weight: 800;
    color:#2c3e50;
    margin-bottom: 8px;
}

#solution{
    font-size: 17px;
    color: #34495e;
    line-height: 1.45;
}

#sumAnim{
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px dashed #d7e2ee;
    font-size: 17px;
    white-space: pre-line;
    color: #2f3f52;
    line-height: 1.45;
    min-height: 42px;
}

#nextBtnWrap{
    margin-top: 12px;
    text-align:center;
}

#nextBtn{
    background: var(--accent);
    border: 1px solid var(--accentBorder);
}

#nextBtn:hover{ background: #dff0ff; }

#stats{
    font-size: 18px;
    margin-top: 14px;
}

#timer{
    font-size: 18px;
    margin-top: 8px;
    color: #2c3e50;
}

#trophy{
    font-size: 64px;
    display:none;
    margin-top: 14px;
}

.pulseHint{
    animation: pulseHint 1.2s ease-in-out infinite;
}

@keyframes pulseHint{
    0%{ transform: scale(1); }
    50%{ transform: scale(1.04); }
    100%{ transform: scale(1); }
}

/* Solution visuals */
.solStepTitle{
    font-weight: 800;
    margin: 10px 0 6px 0;
    color: #2c3e50;
}

.solText{ margin: 4px 0; }

.solRow{
    display:flex;
    align-items:center;
    flex-wrap:wrap;
    gap: 10px;
    margin: 8px 0;
}

.solCoinsRow{
    display:flex;
    align-items:flex-end;
    flex-wrap:wrap;
    gap: 8px;
    margin: 6px 0 10px 0;
}

.solCoinMini{
    width: 44px;
    height: 44px;
    border-radius: 999px;
    border: 3px solid #cfd8e3;
    background: rgba(255,255,255,0.7);
    display:flex;
    justify-content:center;
    align-items:center;
    box-shadow: 0 4px 10px rgba(0,0,0,0.08);
}

.solCoinMini img{
    width: 36px;
    height: 36px;
    border-radius: 999px;
    object-fit: cover;
}

.badge{
    display:inline-block;
    padding: 2px 8px;
    border-radius: 999px;
    border: 1px solid #cfd8e3;
    background: #ffffff;
    color: #34495e;
    font-size: 14px;
    font-weight: 700;
}

.mathBox{
    display:inline-block;
    padding: 10px 12px;
    border-radius: 10px;
    border: 1px solid #dde6f0;
    background: #ffffff;
    font-size: 18px;
    color: #2f3f52;
    box-shadow: 0 4px 12px rgba(0,0,0,0.06);
}

.strike{
    text-decoration: line-through;
    text-decoration-thickness: 3px;
    text-decoration-color: #ef4444;
}

.smallMuted{
    color: var(--muted);
    font-size: 14px;
}

.arrow{
    font-weight: 900;
    color: #51606f;
    font-size: 18px;
}

.fractionLike{
    display:inline-flex;
    align-items:center;
    gap: 10px;
    font-size: 20px;
    font-weight: 800;
}

.divSign{
    font-weight: 900;
    color: #51606f;
}

</style>
</head>

<body>
<div id="app">
    <h1>Cillian's Coin GOAT Game</h1>
    <div id="subhead">Add coins, use multiplication, try mixed questions, and practise subdivision.</div>

    <div id="controls">
        <button id="groupBtn" onclick="toggleGrouping()">Grouping rings: <span id="groupLabel">Off</span></button>
        <button id="modeBtn" onclick="toggleMode()">Mode: <span id="modeLabel">Addition</span></button>
        <button id="currencyBtn" onclick="toggleCurrency()">Answer in: <span id="currencyLabel">pence</span></button>
        <button id="timerBtn" onclick="toggleTimer()">Timer: <span id="timerLabel">Off</span></button>
        <button id="resetBtn" onclick="resetGame()">Reset</button>
    </div>

    <div id="question"></div>
    <div id="helperLine"></div>

    <div id="coins"></div>

    <div id="answerRow">
        <div id="answerBox">
            <span id="prefix"></span>
            <input type="number" id="answer" inputmode="numeric" />
            <span id="suffix"></span>
        </div>
        <button id="checkBtn" onclick="checkAnswer()">Check</button>
    </div>

    <div id="feedback"></div>

    <div id="solutionWrap">
        <div id="solutionCard">
            <div id="solutionTitle">Worked solution - best method</div>
            <div id="solution"></div>
            <div id="sumAnim"></div>
            <div id="nextBtnWrap">
                <button id="nextBtn" onclick="acknowledgeSolution()">I Got It! - Next Question Please</button>
            </div>
        </div>
    </div>

    <div id="stats">
        Streak: <span id="streak">0</span> | Best: <span id="best">0</span>
    </div>

    <div id="timer"></div>
    <div id="trophy">üèÜ</div>

    <audio id="correctSound">
        <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=">
    </audio>
    <audio id="wrongSound">
        <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=">
    </audio>
</div>

<script>
const COINS = [
    { value: 1, img: "coins/1p.jpg",  sizeVar: "--coin-1p" },
    { value: 2, img: "coins/2p.jpg",  sizeVar: "--coin-2p" },
    { value: 5, img: "coins/5p.jpg",  sizeVar: "--coin-5p" },
    { value: 10, img: "coins/10p.jpg", sizeVar: "--coin-10p" },
    { value: 20, img: "coins/20p.png", sizeVar: "--coin-20p" },
    { value: 50, img: "coins/50p.jpg", sizeVar: "--coin-50p" },
    { value: 100, img: "coins/1pound.jpg", sizeVar: "--coin-100p" },
    { value: 200, img: "coins/2pound.png", sizeVar: "--coin-200p" }
];

const RING_COLOURS = {
    200: "#7C3AED",
    100: "#2563EB",
    50:  "#F59E0B",
    20:  "#10B981",
    10:  "#EF4444",
    5:   "#8B5CF6",
    2:   "#06B6D4",
    1:   "#64748B"
};

const SIZE_VAR_BY_VALUE = {
    1: "--coin-1p",
    2: "--coin-2p",
    5: "--coin-5p",
    10: "--coin-10p",
    20: "--coin-20p",
    50: "--coin-50p",
    100: "--coin-100p",
    200: "--coin-200p"
};

const valueToCoin = new Map(COINS.map(c => [c.value, c]));

let groupingRingsOn = false;   // OFF by default
let modes = ["addition", "multiplication", "mixed", "subdivision", "random"];
let modeIndex = 0;

let currency = "pence";
let timerOn = false;

let currentCoins = [];
let answerType = "money";
let correctTotal = 0;
let correctCount = 0;

let subdivisionTarget = null;
let subdivisionType = null;
let subdivisionSmall = null;
let subdivisionLarge = null;
let subdivisionTotalPence = null;

let streak = 0;
let best = 0;

let lockedOnSolution = false;
let timerInterval = null;
let timeLeft = 0;

let animTimeouts = [];

/* ---------- DOM ---------- */
const coinsDiv = document.getElementById("coins");
const questionEl = document.getElementById("question");
const helperEl = document.getElementById("helperLine");
const answerEl = document.getElementById("answer");
const feedbackEl = document.getElementById("feedback");
const solutionWrapEl = document.getElementById("solutionWrap");
const solutionEl = document.getElementById("solution");
const sumAnimEl = document.getElementById("sumAnim");
const prefixEl = document.getElementById("prefix");
const suffixEl = document.getElementById("suffix");
const modeLabelEl = document.getElementById("modeLabel");
const currencyLabelEl = document.getElementById("currencyLabel");
const timerLabelEl = document.getElementById("timerLabel");
const timerEl = document.getElementById("timer");
const trophyEl = document.getElementById("trophy");
const currencyBtn = document.getElementById("currencyBtn");
const groupLabelEl = document.getElementById("groupLabel");

const correctSound = document.getElementById("correctSound");
const wrongSound = document.getElementById("wrongSound");

/* ---------- Helpers ---------- */
function randomInt(min, max){
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function modeLabelFromKey(key){
    if (key === "addition") return "Addition";
    if (key === "multiplication") return "Multiplication";
    if (key === "mixed") return "Mixed";
    if (key === "subdivision") return "Subdivision";
    if (key === "random") return "Random";
    return key;
}

function formatValue(pence){
    return pence >= 100 ? "¬£" + (pence / 100) : pence + "p";
}

function penceToPoundsString(pence){
    return "¬£" + (pence / 100).toFixed(2);
}

function clearAllTimeouts(){
    for (const t of animTimeouts) clearTimeout(t);
    animTimeouts = [];
}

function clearTimer(){
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = null;
    timerEl.textContent = "";
}

function updateStats(){
    document.getElementById("streak").textContent = streak;
    document.getElementById("best").textContent = best;
    trophyEl.style.display = streak >= 10 ? "block" : "none";
}

function updateAnswerAffixes(){
    if (answerType !== "money"){
        prefixEl.textContent = "";
        suffixEl.textContent = "";
        currencyBtn.disabled = true;
        return;
    }
    currencyBtn.disabled = false;
    prefixEl.textContent = currency === "pounds" ? "¬£" : "";
    suffixEl.textContent = currency === "pence" ? "p" : "";
}

function setControlsEnabled(enabled){
    document.getElementById("groupBtn").disabled = !enabled;
    document.getElementById("modeBtn").disabled = !enabled;
    document.getElementById("timerBtn").disabled = !enabled;
    document.getElementById("resetBtn").disabled = !enabled;
    document.getElementById("checkBtn").disabled = !enabled;
    answerEl.disabled = !enabled;

    const currencyEnabled = enabled && (answerType === "money");
    currencyBtn.disabled = !currencyEnabled;
}

function hideSolution(){
    solutionWrapEl.style.display = "none";
    solutionEl.innerHTML = "";
    sumAnimEl.textContent = "";
}

function showSolution(){
    solutionWrapEl.style.display = "block";
}

/* ---------- Coin sizing ---------- */
function sizePxForCoinValue(value){
    const varName = SIZE_VAR_BY_VALUE[value] || "--coin-100p";
    const px = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    return px || "78px";
}

/* ---------- Rendering coins (rings optional) ---------- */
function renderCoins(options = {}){
    const { showDivider=false, dividerText="in" } = options;

    coinsDiv.innerHTML = "";

    if (!showDivider){
        currentCoins.forEach((c, idx) => {
            const wrap = document.createElement("div");
            wrap.className = "coinWrap";
            wrap.dataset.value = String(c.value);
            wrap.dataset.idx = String(idx);

            const sz = sizePxForCoinValue(c.value);
            wrap.style.setProperty("--sz", sz);

            if (groupingRingsOn){
                wrap.style.borderColor = (RING_COLOURS[c.value] || "#cfd8e3");
            } else {
                wrap.style.borderColor = "transparent";
            }

            const img = document.createElement("img");
            img.className = "coinImg";
            img.src = c.img;

            wrap.appendChild(img);
            coinsDiv.appendChild(wrap);
        });
        return;
    }

    const left = currentCoins[0];
    const right = currentCoins[1];

    const wrapL = document.createElement("div");
    wrapL.className = "coinWrap";
    wrapL.dataset.value = String(left.value);
    wrapL.style.setProperty("--sz", sizePxForCoinValue(left.value));
    wrapL.style.borderColor = groupingRingsOn ? (RING_COLOURS[left.value] || "#cfd8e3") : "transparent";
    const imgL = document.createElement("img");
    imgL.className = "coinImg";
    imgL.src = left.img;
    wrapL.appendChild(imgL);

    const div = document.createElement("div");
    div.id = "dividerSymbol";
    div.textContent = dividerText;

    const wrapR = document.createElement("div");
    wrapR.className = "coinWrap";
    wrapR.dataset.value = String(right.value);
    wrapR.style.setProperty("--sz", sizePxForCoinValue(right.value));
    wrapR.style.borderColor = groupingRingsOn ? (RING_COLOURS[right.value] || "#cfd8e3") : "transparent";
    const imgR = document.createElement("img");
    imgR.className = "coinImg";
    imgR.src = right.img;
    wrapR.appendChild(imgR);

    coinsDiv.appendChild(wrapL);
    coinsDiv.appendChild(div);
    coinsDiv.appendChild(wrapR);
}

/* ---------- FLIP animation for grouping (works regardless of ring on/off) ---------- */
function animateGroupCoins(){
    const wraps = Array.from(coinsDiv.querySelectorAll(".coinWrap"));
    if (wraps.length < 2) return;

    const first = new Map();
    wraps.forEach(el => first.set(el, el.getBoundingClientRect()));

    wraps.sort((a, b) => {
        const va = parseInt(a.dataset.value, 10);
        const vb = parseInt(b.dataset.value, 10);
        if (vb !== va) return vb - va;
        return parseInt(a.dataset.idx, 10) - parseInt(b.dataset.idx, 10);
    });

    let lastV = null;
    wraps.forEach(el => el.classList.remove("groupStart"));
    wraps.forEach(el => {
        const v = parseInt(el.dataset.value, 10);
        if (lastV !== null && v !== lastV) el.classList.add("groupStart");
        lastV = v;
    });

    wraps.forEach(el => coinsDiv.appendChild(el));

    wraps.forEach(el => {
        const f = first.get(el);
        const l = el.getBoundingClientRect();
        const dx = f.left - l.left;
        const dy = f.top - l.top;
        el.style.transform = "translate(" + dx + "px," + dy + "px)";
        el.style.transition = "transform 0s";
    });

    coinsDiv.offsetHeight;

    wraps.forEach(el => {
        el.style.transition = "transform 520ms cubic-bezier(0.2, 0.8, 0.2, 1)";
        el.style.transform = "translate(0px,0px)";
    });

    animTimeouts.push(setTimeout(() => {
        wraps.forEach(el => el.classList.add("pulseHint"));
        animTimeouts.push(setTimeout(() => wraps.forEach(el => el.classList.remove("pulseHint")), 1200));
    }, 560));
}

/* ---------- Money teaching solution ---------- */
function buildCoinCountsFromCurrent(){
    const map = new Map();
    currentCoins.forEach(c => map.set(c.value, (map.get(c.value) || 0) + 1));
    return map;
}

function buildMoneyTeachingSolutionHTML(){
    const counts = buildCoinCountsFromCurrent();
    const values = Array.from(counts.keys()).sort((a,b)=>b-a);

    const groupLine = values.map(v => {
        const n = counts.get(v);
        return n > 1 ? n + " √ó " + formatValue(v) : formatValue(v);
    }).join(" + ");

    const multLines = [];
    values.forEach(v => {
        const n = counts.get(v);
        if (n > 1) multLines.push("<div class='solText'><span class='badge'>" + n + " √ó</span> " + v + "p = <b>" + (n*v) + "p</b></div>");
    });
    if (multLines.length === 0) multLines.push("<div class='solText smallMuted'>No repeats this time, so you can just add them.</div>");

    return (
        "<div class='solStepTitle'>Step 1: Group the same coins</div>" +
        "<div class='mathBox'>" + groupLine + "</div>" +
        "<div class='solStepTitle'>Step 2: Do any easy multiplication</div>" +
        multLines.join("") +
        "<div class='solStepTitle'>Step 3: Add from biggest to smallest</div>" +
        "<div class='solText smallMuted'>Watch the running total below.</div>" +
        "<div class='solStepTitle'>Final answer</div>" +
        "<div class='mathBox'><b>" + correctTotal + "p</b> (" + penceToPoundsString(correctTotal) + ")</div>"
    );
}

function startRunningTotalAnimation(){
    clearAllTimeouts();
    sumAnimEl.textContent = "";

    if (answerType !== "money") return;

    const counts = buildCoinCountsFromCurrent();
    const values = Array.from(counts.keys()).sort((a,b)=>b-a);

    let running = 0;
    const steps = [];

    values.forEach(v => {
        const n = counts.get(v);
        const subtotal = n * v;
        running += subtotal;
        const left = (n > 1) ? (n + " √ó " + v + "p") : (v + "p");
        steps.push(left + " = " + subtotal + "p, total = " + running + "p");
    });

    let i = 0;
    sumAnimEl.textContent = "Running total:";

    animTimeouts.push(setTimeout(() => {
        function tick(){
            if (i >= steps.length){
                sumAnimEl.textContent = "Running total:\n" + steps.join("\n") + "\n\nFinal: " + correctTotal + "p (" + penceToPoundsString(correctTotal) + ")";
                return;
            }
            const shown = steps.slice(0, i+1);
            sumAnimEl.textContent = "Running total:\n" + shown.join("\n");
            i += 1;
            animTimeouts.push(setTimeout(tick, 520));
        }
        tick();
    }, 420));
}

/* ---------- Subdivision teaching solution (HTML) ---------- */
function miniCoinHTML(value){
    const coin = valueToCoin.get(value);
    const ring = groupingRingsOn ? (RING_COLOURS[value] || "#cfd8e3") : "#cfd8e3";
    return (
        "<span class='solCoinMini' style='border-color:" + ring + "'>" +
            "<img alt='' src='" + coin.img + "' />" +
        "</span>"
    );
}

function strikeLastKZerosHTML(n, k){
    const s = String(n);
    const zeros = "0".repeat(k);
    if (!s.endsWith(zeros)) return s;
    const head = s.slice(0, s.length - k);
    const struck = "<span class='strike'>" + zeros + "</span>";
    return head + struck;
}

function cancelCommonZeros(a, b){
    let k = 0;
    let aa = a;
    let bb = b;
    while (aa % 10 === 0 && bb % 10 === 0){
        aa = Math.round(aa / 10);
        bb = Math.round(bb / 10);
        k += 1;
        if (k >= 6) break;
    }
    return { k, aReduced: aa, bReduced: bb };
}

function buildSubdivisionTeachingSolutionHTML(){
    if (subdivisionType === "type1"){
        const small = subdivisionSmall;
        const large = subdivisionLarge;

        const cancel = cancelCommonZeros(large, small);
        const k = cancel.k;

        const largeStruck = (k > 0) ? strikeLastKZerosHTML(large, k) : String(large);
        const smallStruck = (k > 0) ? strikeLastKZerosHTML(small, k) : String(small);

        const showCancel = (k > 0);
        const cancelText = (k === 1) ? "Cancel one zero (divide both numbers by 10)" : "Cancel " + k + " zeros (divide both numbers by " + (10 ** k) + ")";

        let divisionBox = "";
        if (showCancel){
            divisionBox =
                "<div class='solRow'>" +
                    "<div class='mathBox fractionLike'>" +
                        "<span>" + largeStruck + "</span>" +
                        "<span class='divSign'>√∑</span>" +
                        "<span>" + smallStruck + "</span>" +
                    "</div>" +
                    "<span class='arrow'>‚Üí</span>" +
                    "<div class='mathBox fractionLike'>" +
                        "<span>" + cancel.aReduced + "</span>" +
                        "<span class='divSign'>√∑</span>" +
                        "<span>" + cancel.bReduced + "</span>" +
                    "</div>" +
                "</div>" +
                "<div class='solText smallMuted'>" + cancelText + "</div>";
        } else {
            divisionBox =
                "<div class='solRow'>" +
                    "<div class='mathBox fractionLike'>" +
                        "<span>" + large + "</span>" +
                        "<span class='divSign'>√∑</span>" +
                        "<span>" + small + "</span>" +
                    "</div>" +
                "</div>" +
                "<div class='solText smallMuted'>No zeros to cancel this time.</div>";
        }

        const reducedA = showCancel ? cancel.aReduced : large;
        const reducedB = showCancel ? cancel.bReduced : small;
        const answer = Math.round(reducedA / reducedB);

        const visualRow =
            "<div class='solCoinsRow'>" +
                "<span class='badge'>Small coin</span> " + miniCoinHTML(small) +
                "<span class='arrow'>in</span>" +
                "<span class='badge'>Big coin</span> " + miniCoinHTML(large) +
            "</div>";

        return (
            "<div class='solStepTitle'>Step 1: Understand the question</div>" +
            "<div class='solText'>How many <b>" + formatValue(small) + "</b> coins fit into <b>" + formatValue(large) + "</b>?</div>" +
            visualRow +
            "<div class='solStepTitle'>Step 2: Turn it into a division</div>" +
            "<div class='solText'><span class='badge'>Divide</span> " + large + "p √∑ " + small + "p</div>" +
            "<div class='solStepTitle'>Step 3: Make the division easier</div>" +
            divisionBox +
            "<div class='solStepTitle'>Step 4: Divide</div>" +
            "<div class='mathBox'><b>" + reducedA + " √∑ " + reducedB + " = " + answer + "</b></div>" +
            "<div class='solStepTitle'>Step 5: Quick check</div>" +
            "<div class='solText'>" + answer + " √ó " + small + "p = <b>" + (answer * small) + "p</b> (which matches " + large + "p)</div>" +
            "<div class='solStepTitle'>Final answer</div>" +
            "<div class='mathBox'><b>" + correctCount + "</b></div>"
        );
    }

    const target = subdivisionTarget || 1;
    const total = subdivisionTotalPence !== null ? subdivisionTotalPence : currentCoins.reduce((a,c)=>a+c.value,0);

    const coinSetVisual =
        "<div class='solCoinsRow'>" +
            currentCoins.map(c => miniCoinHTML(c.value)).join("") +
        "</div>";

    const cancel = cancelCommonZeros(total, target);
    const showCancel = cancel.k > 0;

    const totalStruck = showCancel ? strikeLastKZerosHTML(total, cancel.k) : String(total);
    const targetStruck = showCancel ? strikeLastKZerosHTML(target, cancel.k) : String(target);
    const cancelText = (cancel.k === 1) ? "Cancel one zero (divide both numbers by 10)" : "Cancel " + cancel.k + " zeros (divide both numbers by " + (10 ** cancel.k) + ")";

    const divisionBox =
        showCancel
        ? (
            "<div class='solRow'>" +
                "<div class='mathBox fractionLike'>" +
                    "<span>" + totalStruck + "</span>" +
                    "<span class='divSign'>√∑</span>" +
                    "<span>" + targetStruck + "</span>" +
                "</div>" +
                "<span class='arrow'>‚Üí</span>" +
                "<div class='mathBox fractionLike'>" +
                    "<span>" + cancel.aReduced + "</span>" +
                    "<span class='divSign'>√∑</span>" +
                    "<span>" + cancel.bReduced + "</span>" +
                "</div>" +
            "</div>" +
            "<div class='solText smallMuted'>" + cancelText + "</div>"
        )
        : (
            "<div class='solRow'>" +
                "<div class='mathBox fractionLike'>" +
                    "<span>" + total + "</span>" +
                    "<span class='divSign'>√∑</span>" +
                    "<span>" + target + "</span>" +
                "</div>" +
            "</div>" +
            "<div class='solText smallMuted'>No zeros to cancel this time.</div>"
        );

    const reducedA = showCancel ? cancel.aReduced : total;
    const reducedB = showCancel ? cancel.bReduced : target;
    const answer = Math.round(reducedA / reducedB);

    return (
        "<div class='solStepTitle'>Step 1: Find the total</div>" +
        "<div class='solText'>Add the coins you are given:</div>" +
        coinSetVisual +
        "<div class='mathBox'><b>Total = " + total + "p</b></div>" +
        "<div class='solStepTitle'>Step 2: Divide by the coin you want</div>" +
        "<div class='solText'>You want " + formatValue(target) + " coins, so do: <b>" + total + "p √∑ " + target + "p</b></div>" +
        "<div class='solStepTitle'>Step 3: Make the division easier</div>" +
        divisionBox +
        "<div class='solStepTitle'>Step 4: Divide</div>" +
        "<div class='mathBox'><b>" + reducedA + " √∑ " + reducedB + " = " + answer + "</b></div>" +
        "<div class='solStepTitle'>Step 5: Quick check</div>" +
        "<div class='solText'>" + answer + " √ó " + target + "p = <b>" + (answer * target) + "p</b> (which matches " + total + "p)</div>" +
        "<div class='solStepTitle'>Final answer</div>" +
        "<div class='mathBox'><b>" + correctCount + "</b></div>"
    );
}

/* ---------- Problem generators ---------- */
function generateAddition(){
    answerType = "money";
    currentCoins = [];
    correctTotal = 0;

    subdivisionType = null;
    subdivisionTarget = null;
    subdivisionSmall = null;
    subdivisionLarge = null;
    subdivisionTotalPence = null;

    const count = randomInt(2, 4);
    for (let i=0;i<count;i++){
        const c = COINS[randomInt(0, COINS.length-1)];
        currentCoins.push(c);
        correctTotal += c.value;
    }

    questionEl.textContent = "Add up the coins";
    helperEl.textContent = currentCoins.map(c => formatValue(c.value)).join(" + ");
    renderCoins();
}

function generateMultiplication(){
    answerType = "money";
    currentCoins = [];

    subdivisionType = null;
    subdivisionTarget = null;
    subdivisionSmall = null;
    subdivisionLarge = null;
    subdivisionTotalPence = null;

    const c = COINS[randomInt(0, COINS.length-1)];
    const n = randomInt(2, 4);
    for (let i=0;i<n;i++) currentCoins.push(c);
    correctTotal = c.value * n;

    questionEl.textContent = n + " √ó " + formatValue(c.value);
    helperEl.textContent = "Think: " + formatValue(c.value) + " added " + n + " times";
    renderCoins();
}

function generateMixed(){
    answerType = "money";
    currentCoins = [];
    correctTotal = 0;

    subdivisionType = null;
    subdivisionTarget = null;
    subdivisionSmall = null;
    subdivisionLarge = null;
    subdivisionTotalPence = null;

    const base = COINS[randomInt(0, COINS.length-1)];
    const n = randomInt(2, 4);
    for (let i=0;i<n;i++){
        currentCoins.push(base);
        correctTotal += base.value;
    }

    let expr = "(" + n + " √ó " + formatValue(base.value) + ")";

    const extras = randomInt(1, 2);
    for (let i=0;i<extras;i++){
        let extra;
        do { extra = COINS[randomInt(0, COINS.length-1)]; }
        while (extra.value === base.value);
        currentCoins.push(extra);
        correctTotal += extra.value;
        expr += " + " + formatValue(extra.value);
    }

    questionEl.textContent = expr;
    helperEl.textContent = "Do the brackets first, then add the extra coin(s)";
    renderCoins();
}

function pickSubdivisionPair(){
    const smallChoices = [1,2,5,10,20,50];
    const largeChoices = [10,20,50,100,200];
    let small, large;
    let safety = 0;
    do{
        small = smallChoices[randomInt(0, smallChoices.length-1)];
        large = largeChoices[randomInt(0, largeChoices.length-1)];
        safety += 1;
        if (safety > 200) break;
    }while (large <= small || (large % small !== 0));
    return { small, large };
}

function makeRandomCoinSetWithTotal(totalPence, minCoins, maxCoins, allowedValues){
    const allowed = allowedValues.slice().sort((a,b)=>b-a);
    let best = null;

    for (let attempt=0; attempt<220; attempt++){
        let remaining = totalPence;
        let picked = [];
        const shuffled = allowed.slice().sort(() => Math.random() - 0.5);

        for (let i=0;i<120;i++){
            if (remaining <= 0) break;
            const v = shuffled[randomInt(0, shuffled.length-1)];
            if (v <= remaining){
                picked.push(v);
                remaining -= v;
                if (picked.length >= maxCoins && remaining > 0) break;
            }
        }

        if (remaining === 0 && picked.length >= minCoins && picked.length <= maxCoins){
            best = picked;
            break;
        }
    }

    if (!best){
        best = [];
        let remaining = totalPence;
        const fallback = allowed.slice().sort((a,b)=>b-a);
        for (const v of fallback){
            while (remaining >= v && best.length < maxCoins){
                best.push(v);
                remaining -= v;
            }
        }
        while (remaining > 0){
            best.push(1);
            remaining -= 1;
        }
    }

    return best.map(v => valueToCoin.get(v));
}

function generateSubdivision(){
    answerType = "count";
    currentCoins = [];
    correctCount = 0;

    const type = randomInt(0,1);

    if (type === 0){
        subdivisionType = "type1";
        subdivisionTarget = null;
        subdivisionTotalPence = null;

        const { small, large } = pickSubdivisionPair();
        subdivisionSmall = small;
        subdivisionLarge = large;

        currentCoins = [valueToCoin.get(small), valueToCoin.get(large)];
        correctCount = Math.round(large / small);

        questionEl.textContent = "How many " + formatValue(small) + " coins are in " + formatValue(large) + "?";
        helperEl.textContent = "Think: divide the big value by the small value";
        renderCoins({ showDivider: true, dividerText: "in" });
        return;
    }

    subdivisionType = "type2";
    subdivisionSmall = null;
    subdivisionLarge = null;

    const targetChoices = [1,2,5,10];
    const target = targetChoices[randomInt(0, targetChoices.length-1)];
    subdivisionTarget = target;

    const targetCount = randomInt(4, 20);
    const totalPence = target * targetCount;
    subdivisionTotalPence = totalPence;

    currentCoins = makeRandomCoinSetWithTotal(totalPence, 2, 5, [1,2,5,10,20,50,100,200]);
    correctCount = Math.round(totalPence / target);

    questionEl.textContent = "How many " + formatValue(target) + " coins can you get for these coins?";
    helperEl.textContent = "Find the total, then divide by " + formatValue(target);
    renderCoins();
}

/* ---------- Main flow ---------- */
function generateQuestion(){
    clearAllTimeouts();
    clearTimer();

    feedbackEl.textContent = "";
    answerEl.value = "";
    hideSolution();

    lockedOnSolution = false;
    setControlsEnabled(true);

    let mode = modes[modeIndex];
    if (mode === "random"){
        mode = ["addition","multiplication","mixed","subdivision"][randomInt(0,3)];
    }

    if (mode === "addition") generateAddition();
    if (mode === "multiplication") generateMultiplication();
    if (mode === "mixed") generateMixed();
    if (mode === "subdivision") generateSubdivision();

    updateAnswerAffixes();
    currencyLabelEl.textContent = currency;

    if (timerOn) startTimer();
}

/* ---------- Timer ---------- */
function startTimer(){
    clearTimer();
    timeLeft = 10;
    timerEl.textContent = "Time left: " + timeLeft;

    timerInterval = setInterval(() => {
        timeLeft -= 1;
        timerEl.textContent = "Time left: " + timeLeft;
        if (timeLeft <= 0){
            clearTimer();
            handleWrong(true);
        }
    }, 1000);
}

/* ---------- Answer checking ---------- */
function readUserNumber(){
    const raw = answerEl.value;
    if (raw === null || raw === undefined || raw === "") return null;
    const n = parseFloat(raw);
    if (isNaN(n)) return null;
    return n;
}

function checkAnswer(){
    if (lockedOnSolution) return;

    const n = readUserNumber();
    if (n === null) return;

    if (answerType === "count"){
        const userCount = Math.round(n);
        if (userCount === correctCount){
            try{ correctSound.play(); }catch(e){}
            streak += 1;
            best = Math.max(best, streak);
            feedbackEl.textContent = "Correct! üéâ";
            updateStats();
            clearTimer();
            animTimeouts.push(setTimeout(generateQuestion, 700));
        } else {
            handleWrong(false);
        }
        return;
    }

    const userPence = currency === "pounds" ? Math.round(n * 100) : Math.round(n);
    if (userPence === correctTotal){
        try{ correctSound.play(); }catch(e){}
        streak += 1;
        best = Math.max(best, streak);
        feedbackEl.textContent = "Correct! üéâ";
        updateStats();
        clearTimer();
        animTimeouts.push(setTimeout(generateQuestion, 800));
    } else {
        handleWrong(false);
    }
}

/* ---------- Wrong answer flow ---------- */
function handleWrong(fromTimer){
    if (lockedOnSolution) return;

    clearTimer();
    clearAllTimeouts();

    try{ wrongSound.play(); }catch(e){}

    feedbackEl.textContent = fromTimer ? "Time is up. Here is the best way to work it out:" : "Not quite. Here is the best way to work it out:";

    lockedOnSolution = true;
    setControlsEnabled(false);
    document.getElementById("resetBtn").disabled = false;

    if (answerType === "money"){
        solutionEl.innerHTML = buildMoneyTeachingSolutionHTML();
    } else {
        solutionEl.innerHTML = buildSubdivisionTeachingSolutionHTML();
    }

    showSolution();

    const hasDivider = coinsDiv.querySelector("#dividerSymbol") !== null;
    if (answerType === "money" && !hasDivider){
        animTimeouts.push(setTimeout(() => animateGroupCoins(), 120));
    }

    if (answerType === "money"){
        startRunningTotalAnimation();
    } else {
        sumAnimEl.textContent = "";
    }

    streak = 0;
    updateStats();
}

function acknowledgeSolution(){
    lockedOnSolution = false;
    setControlsEnabled(true);
    hideSolution();
    generateQuestion();
}

/* ---------- Controls ---------- */
function toggleGrouping(){
    if (lockedOnSolution) return;
    groupingRingsOn = !groupingRingsOn;
    groupLabelEl.textContent = groupingRingsOn ? "On" : "Off";
    renderCoins({ showDivider: (coinsDiv.querySelector("#dividerSymbol") !== null) });
}

function toggleMode(){
    if (lockedOnSolution) return;
    modeIndex = (modeIndex + 1) % modes.length;
    modeLabelEl.textContent = modeLabelFromKey(modes[modeIndex]);
    generateQuestion();
}

function toggleCurrency(){
    if (lockedOnSolution) return;
    if (answerType !== "money") return;
    currency = currency === "pence" ? "pounds" : "pence";
    currencyLabelEl.textContent = currency;
    updateAnswerAffixes();
}

function toggleTimer(){
    if (lockedOnSolution) return;
    timerOn = !timerOn;
    timerLabelEl.textContent = timerOn ? "On" : "Off";
    generateQuestion();
}

function resetGame(){
    clearAllTimeouts();
    clearTimer();
    lockedOnSolution = false;
    streak = 0;
    best = 0;
    updateStats();
    hideSolution();
    generateQuestion();
}

/* ---------- Keyboard ---------- */
answerEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter") checkAnswer();
});

/* ---------- Init ---------- */
groupLabelEl.textContent = "Off";
modeLabelEl.textContent = modeLabelFromKey(modes[modeIndex]);
currencyLabelEl.textContent = currency;
timerLabelEl.textContent = "Off";
updateStats();
generateQuestion();
</script>
</body>
</html>
